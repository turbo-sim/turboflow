
import jax.numpy as jnp
from jax import grad
import turboflow as tf

# Define the specific gas constant, for air R is around 287 J/(kg*K)
R = 287.0

# Define the specific heat ratio for air
gamma = 1.41 

# Define reference values and constants for temperature and pressure
T_ref = 288.15 # 15 degree celsius (K)
rho_ref = 1.225 # (Kg/m^3)
# P_atm = 101325.0 # 1 atm pressure
# P_ref = 1.3860*P_atm # Pa 
P_ref = 101306.33 # Pa
# s_ref = 1702.03 # J/(Kg*K)
s_ref = 1659.28 # J/(Kg*K)
myu_ref = 1.789*1e-5 # (Kg/(m*s))
S_myu = 110.56 # K Sutherland's constant for viscosity Source: https://www.afs.enea.it/project/neptunius/docs/fluent/html/ug/node294.htm
k_ref = 0.0241 # W/(m*K)
S_k = 194 # K Sutherland's constant for viscosity Source: https://doc.comsol.com/5.5/doc/com.comsol.help.cfd/cfd_ug_fluidflow_high_mach.08.27.html
T_ref_k = 273 # K

# Define the ideal gas equation of state in terms of enthalpy and entropy: 

# def ideal_gas_equation(h, s):
#     Cp, Cv = specific_heat(R, gamma) # specific heats at constant pressure and volume respectively
#     T = (h/Cp) # Temperature 
#     P = P_ref*(jnp.exp(((Cp*jnp.log(T/T_ref)) - (s - s_ref))/R)) # Pressure
#     rho = P/(R*T)  # density

#     a = jnp.sqrt(gamma*R*T)

#     return T, P, rho

# Define the ideal gas equation of state: p = rho * R * T
def ideal_gas_equation(rho, T):
    return rho * R * T

def specific_heat(R, gamma):
    Cp = (gamma*R)/(gamma - 1) # specific heat at constant pressure units J/(Kg*K)
    Cv = Cp/gamma # specific heat at constant volume units J/(Kg*K)
    return Cp, Cv

# def specific_heat(T, R):
#     a = 28.11
#     b = 0.1967*(10**-2)
#     c = 0.4802*(10**-5)
#     d = -1.966*(10**-9)

#     Cp = a + b*T + c*(T**2) + d*(T**3)
#     Cv = Cp - R

#     return Cp, Cv


Cp, Cv = specific_heat(R, gamma) # specific heats at constant pressure and volume respectively

def temperature(h,s):
    T = (h/Cp) # Temperature 
    return T

def pressure(h,s):
    T = temperature(h,s)
    P = P_ref*(jnp.exp(((Cp*jnp.log(T/T_ref)) - (s - s_ref))/R)) # Pressure
    return P

def density(h,s):
    T = temperature(h,s)
    P = pressure(h,s)
    rho = P/(R*T)
    return rho

def viscosity(h,s):
    # Using Sutherland's formula for dynamic viscosity as a function if temperature
    T = temperature(h,s)
    myu = myu_ref*((T/T_ref)**(3/2))*((T_ref + S_myu)/(T + S_myu))
    return myu

def thermal_conductivity(h,s):
    # Using Sutherland's formula for thermal conductivity as a function if temperature
    T = temperature(h,s)
    k = k_ref*((T/T_ref_k)**(3/2))*((T_ref_k + S_k)/(T + S_k))
    return k


# Example input: enthalpy (h) and entropy (s)
# h = 300190 J/Kg, s = 1702.03 J/(Kg*K)
h, s = 400980.0 , 1991.94

T = temperature(h,s)
P = pressure(h,s)
rho = density(h,s)
myu = viscosity(h,s)
k = thermal_conductivity(h,s)

print("Temperature:", T, "\nPressure:", P, "\nDensity:", rho, "\nEnthalpy:", h, "\nEntropy:", s, "\nViscosity:", myu, "\nThermal Conductivity:", k)

# Compute the partial derivatives
# thermodynamic_properties = ideal_gas_equation(h, s)
# dp_dh = grad(thermodynamic_properties[1], argnums=0)    # Partial derivative with respect to h
# dp_ds = grad(thermodynamic_properties[1], argnums=1)    # Partial derivative with respect to s

dP_dh = grad(pressure, argnums=0)    # Partial derivative with respect to h at constant s
dP_ds = grad(pressure, argnums=1)    # Partial derivative with respect to s at constant h

dT_dh = grad(temperature, argnums=0)    # Partial derivative with respect to h at constant s
dT_ds = grad(temperature, argnums=1)    # Partial derivative with respect to s at constant h

drho_dh = grad(density, argnums=0)    # Partial derivative with respect to h at constant s
drho_ds = grad(density, argnums=1)    # Partial derivative with respect to s at constant h

# With Inputs T and rho
dP_drho = grad(ideal_gas_equation, argnums=0)  # Partial derivative with respect to rho
dP_dT = grad(ideal_gas_equation, argnums=1)    # Partial derivative with respect to T


# Calculate the partial derivatives for the given input
dP_dh_s = dP_dh(h, s)
dP_ds_h = dP_ds(h, s)

dT_dh_s = dT_dh(h, s)
dT_ds_h = dT_ds(h, s)

drho_dh_s = drho_dh(h, s)
drho_ds_h = drho_ds(h, s)

dP_dT_s = dP_dh_s/dT_dh_s
dP_drho_h = dP_ds_h/drho_ds_h

dP_dT_rho = dP_dT(rho, T)
dP_drho_T = dP_drho(rho, T)


# Now compare using turboflow's approx_gradient for finite differences
def wrapped_ideal_gas(rho_T):
    rho, T = rho_T  # rho and T are the inputs
    return ideal_gas_equation(rho, T)

gradient_approx = tf.approx_gradient(wrapped_ideal_gas, x=jnp.asarray([rho, T]), method="3-point", abs_step=1e-3)


# Verifying the results from AD 

print(dP_dT_s, (gamma/(gamma - 1))*dP_dT_rho)
print(dP_drho_h, dP_drho_T)

if round(dP_dT_s - ((gamma/(gamma - 1))*dP_dT_rho)) == 0 and round(dP_drho_h - dP_drho_T) == 0:
    print("The partial derivatives calculated from AD method from different forms of equation of state are matching")
else:
    print("The partial derivatives calculated from AD method from different forms of equation of state are not matching")

# Print the results
print("Partial derivative of pressure wrt rho (AD):", dP_drho_T)
print("Partial derivative of pressure wrt rho (FD):", gradient_approx[0])
print("Partial derivative of pressure wrt T (AD):", dP_dT_rho)
print("Partial derivative of pressure wrt T (DF):", gradient_approx[1])

# import CoolProp as CP

# def get_props_perfect_gas(input_pair, input_1, input_2):
#     # Check Sutherlands equation to compute viscosity

#     if input_pair == CP.HmassSmass_INPUTS:
#         h, s = input_1, input_2
#         T = temperature(h, s)
#         p = pressure(h, s)
#         d = density(h, s)
#         props = {}
#         props["p"] = p
#         props["T"] = T
#         props["d"] = d
#         # pass
#     elif input_pair == CP.PT_INPUTS:
#         pass

#     elif input_pair == CP.HmassP_INPUTS:
#         pass

#     else:
#         raise ValueError(f"The input pair provided is invalid. Given value: {input_pair}")
    

#     return props



# props = get_props_perfect_gas(CP.HmassSmass_INPUTS, h, s)
# dict2 = {"viscosity": 4, "speed of sound": 100}
# props["nested1"] = dict2
# props["nested2"] = dict2
# props["nested3"] = dict2
# tf.print_dict(props)

